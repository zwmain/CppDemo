# 基于TCP的服务端/客户端(1)

## 理解TCP和UDP

根据数据传输方式的不同，基于网络协议的套接字一般分为TCP套接字和UDP套接字。
因为TCP套接字是面向连接的，因此又称基于流(stream)的套接字。

TCP是Transmission Control Protocol(传输控制协议)的简写意为“对数据传输过程的控制因此，学习控制方法及范围有助于正确理解TCP套接字。

TCP/IP协议栈

讲解TCP前先介绍TCP所属的TCP/IP协议栈(Stack，层)

1. 链路层
2. IP层
3. 传输层：TCP/UDP
4. 应用层

TCP/IP协议栈共分4层，可以理解为数据收发分成了4个层次化过程。也就是说，面对“基于互联网的有效数据传输”的命题，并非通过1个庞大协议解决问题，而是化整为零，通过层次化方案-TCP/IP协议栈解决。通过TCP/UDP套接字收发数据时需要借助这4层

TCP与UDP只在传输层不同。

> 这里分为4层，其实与OSI7层模型有很多共通的地方

TCP/IP协议的诞生背景

“通过因特网完成有效数据传输”这个课题让许多专家聚集到了一起，这些人是硬件、系统路由算法等各领域的顶级专家。为何需要这么多领域的专家呢?

我们之前只关注套接字创建及应用，却忽略了计算机网络问题并非仅凭软件就能解决。编写软件前需要构建硬件系统，在此基础上需要通过软件实现各种算法。所以才需要众多领域的专家进行讨论，以形成各种规定。因此，把这个大问题划分成若干小问题再逐个攻破，将大幅提高效率。

把“通过因特网完成有效数据传输”问题按照不同领域划分成小问题后，出现多种协议，它们通过层级结构建立了紧密联系。

链路层

接下来逐层了解TCP/IP协议栈，先讲解链路层。链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换则需要物理连接，链路层就负责这些标准。

IP层

准备好物理连接后就要传输数据。为了在复杂的网络中传输数据,首先需要考虑路径的选择。
向目标传输数据需要经过哪条路径?解决此问题就是IP层，该层使用的协议就是IP。

IP本身是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径;但如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。

传输层，TCP/UDP层

IP层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP和UDP层以IP层提供的路径信息为基础完成实际的数据传输，故该层又称传输层(Transport)。UDP比TCP简单，我们将在后续章节展开讨论，现只解释TCP。TCP可以保证可靠的数据传输，但它发送数据时以IP层为基础(这也是协议栈结构层次化的原因)。那该如何理解二者关系呢?

IP层只关注1个数据包(数据传输的基本单位)的传输过程。因此，即使传输多个数据包每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则有可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A.B、C中有可能只收到A和C，甚至收到的C可能已损毁。反之，若添加TCP协议则按照如下对话方式进行数据交换。

主机A:“正确收到第二个数据包!

主机B:“恩，知道了。”

主机A:“正确收到第三个数据包!”

主机B:“可我已发送第四个数据包了啊!哦，您没收到第四个数据包吧?我给您重传!”

这就是TCP的作用。如果数据交换过程中可以确认对方已收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的

总之，TCP和UDP存在于IP层之上，决定主机之间的数据传输方式，TCP协议确认后向不可靠的IP协议赋予可靠性。

应用层

上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部。而与其说是“隐藏”，倒不如“使程序员从这些细节中解放出来”的表达更为准确。程序员编程时无需考虑这些过程，但这并不意味着不用掌握这些知识。只有掌握了这些理论，才能编写出符合需求的网络程序。

总之，向各位提供的工具就是套接字，大家只需利用套接字编出程序即可。编写软件的过程中，需要根据程序特点决定服务器端和客户端之间的数据传输规则(规定)，这便是应用层协议网络编程的大部分内容就是设计并实现应用层协议。





## 实现基于TCP的服务器端/客户端

本节实现完整的TCP服务器端，在此过程中各位将理解套接字使用方法及数据传输方法。

TCP服务器端的默认函数调用顺序

1. `socket()`创建套接字
2. `bind()`分配套接字地址
3. `listen()`进入监听状态
4. `accept()`接收请求
5. `read()/write()`数据交换
6. `close()`断开连接

调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。这2个阶段之前都已讨论过，下面讲解之后的几个过程。

进入等待连接请求状态

我们已调用bind函数给套接字分配了地址，接下来就要通过调用listen函数进入等待连接请求状态。只有调用了listen函数，客户端才能进入可发出连接请求的状态。换言之，这时客户端才能调用connect函数(若提前调用将发生错误)。

```c
#include<sys/socket.h>
int listen(int sock, int backlog);
// 成功时返回0，失败时返回-1。
// sock     希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字(监听套接字)。
// backlog  连接请求等待队列(Queue)的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列。

```

先解释一下等待连接请求状态的含义和连接请求等待队列。“服务器端处于等待连接请求状是指，客户端请求连接时，受理连接前一直使请求处于等待状态。

作为listen函数的第一个参数传递的文件描述符套接字的用途。客户端连接请求本身也是从网络中接收到的一种数据，而要想接收就需要套接字。此任务就由服务器端套接字完成。服务器端套接字是接收连接请求的一名门卫或一扇门。

客户端如果向服务器端询问:“请问我是否可以发起连接?”服务器端套接字就会亲切应答:“您好!当然可以，但系统正忙，请到等候室排号等待，准备好后会立即受理您的连接。”同时将连接请求请到等候室。调用listen函数即可生成这种门卫(服务器端套接字)listen函数的第二个参数决定了等候室的大小。等候室称为连接请求等待队列，准备好服务器端套接字和连接请求等待队列后，这种可接收连接请求的状态称为等待连接请求状态

listen函数的第二个参数值与服务器端的特性有关,像频繁接收请求的Web服务器端至少应为15。另外，连接请求队列的大小始终根据实验结果而定。

受理客户端连接请求

调用listen函数后，若有新的连接请求，则应按序受理。受理请求意味着进入可接受数据的状态。也许各位已经猜到进入这种状态所需部件一-当然是套接字!大家可能认为可以使用服务器端套接字，但服务器端套接字是做门卫的。如果在与客户端的数据交换中使用门卫，那谁来守门呢?因此需要另外一个套接字，但没必要亲自创建。下面这个函数将自动创建套接字，并连接到发起请求的客户端。

```c
#include <sys/socket.h>
int accept(int sock, struct sockaddr * addr, socklent * addrlen);
// 成功时返回创建的套接字文件描述符，失败时返回-1。
// sock         服务器套接字的文件描述符
// addr         保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息。
// addrlen      第二个参数addr结构体的长度，但是存有长度的变量地址。函数调用完成后，该变量即被填入客户端地址长度。

```

accept函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符。需要强调的是，套接字是自动创建的并自动与发起连接请求的客户端建立连接。

TCP客户端的默认函数调用顺序

接下来讲解客户端的实现顺序。如前所述，这要比服务器端简单许多。因为创建套接字和请求连接就是客户端的全部内容

1. `socket()`创建套接字
2. `connect()`请求连接
3. `read()/write()`交换数据
4. `close()`断开连接

与服务器端相比，区别就在于“请求连接”，它是创建客户端套接字后向服务器端发起的连接请求。服务器端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。那如何发起连接请求呢?通过调用如下函数完成。

```c
#include <sys/socket.h>
int connect(int sock, struct sockaddr * servaddr, socklen_t addrlen);
// 成功时返回0失败时返回-1。
// sock         客户端套接字文件描述符。
// servaddr     保存目标服务器端地址信息的变量地址值。
// addrlen      以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度。

```

客户端调用connect函数后，发生以下情况之一才会返回(完成函数调用)。

- 服务器端接收连接请求
- 发生断网等异常情况而中断连接请求

需要注意，所谓的“接收连接”并不意味着服务器端调用accept函数，其实是服务器端把连接请求信息记录到等待队列。因此connect函数返回后并不立即进行数据交换。

客户端套接字地址信息在哪?

> 实现服务器端必经过程之一就是给套接字分配IP和端口号。但客户端实现过程中并未出现套接字地址分配，而是创建套接字后立即调用connect函数。难道客户端套接字无需分配IP和端口?当然不是!网络数据交换必须分配IP和端口。既然如此，那客户端套接字何时、何地、如何分配地址呢?
>
> - 何时?调用connect函数时。
> - 何地?操作系统，更准确地说是在内核中
> - 如何?IP用计算机(主机)的IP，端口随机。
>
> 客户端的IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。




## 实现选代服务器端/客户端




## 基于Windows的实现






