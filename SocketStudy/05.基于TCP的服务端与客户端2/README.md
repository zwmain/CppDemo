# 基于TCP的服务器端/客户端（2）

## 回声客户端的完美实现


第4章已分析过回声客户端存在的问题，此处不再赘述。如果大家不太理解，请复习第2章的TCP传输特性和第4章的内容。

**回声服务器端没有问题，只有回声客户端有问题？**

问题不在服务器端，而在客户端。但只看代码也许不太好理解，因为I/O中使用了相同的函数。先回顾一下回声服务器端的I/O相关代码，下面是echo_server.c的第50~51行代码。

```c
while((str_len=read(clnt_sock,message,BUF_SIZE))!= 0)
    write(clnt_sock, message, str_len);
```

接着回顾回声客户端代码，下面是echo_client.c的第45~46行代码。

```c
write(sock, message, strlen(message));
str_len = read(sock,message,BUF_SIZE - 1);
```

二者都在循环调用read或write函数。实际上之前的回声客户端将100%接收自己传输的数据，只不过接收数据时的单位有些问题。扩展客户端代码回顾范围，下面是echo_client.c第37行开始的代码。

```c
while(1) {
    fputs("Input message(Q to quit):",stdout);
    fgets(message,BUF_SIZE,stdin);
    write(sock, message, strlen(message));
    str_len = read(sock,message,BUF_SIZE - 1);
    message[str_len] = 0;
    printf("Message from server:%s",message);
}
```

大家现在理解了吧？回声客户端传输的是字符串，而且是通过调用write函数一次性发送的。之后还调用一次read函数，期待着接收自己传输的字符串。这就是问题所在。

“既然回声客户端会收到所有字符串数据，是否只需多等一会儿？过一段时间后再调用read函数是否可以一次性读取所有字符串数据？"

的确，过一段时间后即可接收，但需要等多久？要等10分钟吗？这不符合常理，理想的客户端应在收到字符串数据时立即读取并输出。

**回声客户端问题解决方法**

我说的回声客户端问题实际上是初级程序员经常犯的错误，其实很容易解决，因为可以提前确定接收数据的大小。若之前传输了20字节长的字符串，则在接收时循环调用read函数读取20个字节即可。


**如果问题不在于回声客户端：定义应用层协议**

回声客户端可以提前知道接收的数据长度，但我们应该意识到，更多情况下这不太可能。既然如此，若无法预知接收数据长度时应如何收发数据？此时需要的就是应用层协议的定义。之前的回声服务器端/客户端中定义了如下协议。

“收到Q就立即终止连接。”

同样，收发数据过程中也需要定好规则（协议）以表示数据的边界，或提前告知收发数据的大小。服务器端（客户端实现过程中逐步定义的这些规则集合就是应用层协议。可以看出，应用层协议并不是高深莫测的存在，只不过是为特定程序的实现而制定的规则。

## TCP原理

**TCP套接字中的I/O缓冲**

如前所述，TCP套接字的数据收发无边界。服务器端即使调用1次write函数传输40字节的数据，客户端也有可能通过4次read函数调用每次读取10字节。但此处也有一些疑问，服务器端一次性传输了40字节，而客户端居然可以缓慢地分批接收。客户端接收10字节后，剩下的30字节在何处等候呢？是不是像飞机为等待着陆而在空中盘旋一样，剩下30字节也在网络中徘徊并等待接收呢？

实际上，write函数调用后并非立即传输数据，read函数调用后也并非马上接收数据。更准确地说，write函数调用瞬间，数据将移至输出缓冲;read函数调用瞬间，从输入缓冲读取数据。

调用write函数时，数据将移到输出缓冲，在适当的时候(不管是分别传送还是一次性传送)传向对方的输入缓冲。这时对方将调用read函数从输入缓冲读取数据。这些I/0缓冲特性可整理如下。

- I/O缓冲在每个TCP套接字中单独存在。
- I/O缓冲在创建套接字时自动生成。
- 即使关闭套接字也会继续传递输出缓冲中遗留的数据。
- 关闭套接字将丢失输入缓冲中的数据。

那么，下面这种情况会引发什么事情?理解了I/O缓冲后，各位应该可以猜出其流程:

客户端输入缓冲为50字节，而服务器端传输了100字节。

这的确是个问题。输入缓冲只有50字节，却收到了100字节的数据。可以提出如下解决方案:

“填满输入缓冲前迅速调用read函数读取数据，这样会腾出一部分空间，问题就解决了。”

当然，这只是我的一个小玩笑，相信大家不会当真，那么马上给出结论

“不会发生超过输入缓冲大小的数据传输。”

也就是说，根本不会发生这类问题，因为TCP会控制数据流。TCP中有滑动窗口(SlidingWindow)协议，用对话方式呈现如下。

- 套接字A: 你好，最多可以向我传递50字节。
- 套接字B: OK!
- 套接字A: 我腾出了20字节的空间，最多可以收70字节。
- 套接字B: OK!

数据收发也是如此，因此TCP中不会因为缓冲溢出而丢失数据

> 从write函数返回的时间点
>
> write函数和Windows的send函数并不会在完成向对方主机的数据传输时返回，而是在数据移到输出缓冲时。
> 但TCP会保证对输出缓冲数据的传输所以说write函数在数据传输完成时返回。要准确理解这句话。

**TCP内部工作原理1：与对方套接字的连接**

TCP套接字从创建到消失所经过程分为如下3步。

- 与对方套接字建立连接。
- 与对方套接字进行数据交换。
- 断开与对方套接字的连接。

首先讲解与对方套接字建立连接的过程。连接过程中套接字之间的对话如下。

- 【Shake 1】套接字A："你好，套接字B。我这儿有数据要传给你，建立连接吧。"
- 【Shake 2】套接字B：“好的，我这边已就绪。”
- 【Shake 3】套接字A：“谢谢你受理我的请求。”

TCP在实际通信过程中也会经过3次对话过程，因此，该过程又称Three-way handshaking（三次握手）。接下来给出连接过程中实际交换的信息格式

套接字是以全双工（Full-duplex）方式工作的。也就是说，它可以双向传递数据。因此，收发数据前需要做一些准备。首先，请求连接的主机A向主机B传递如下信息：

\[SYN\] SEQ:1000,ACK:-

该消息中SEQ为1000，ACK为空，而SEQ为1000的含义如下：

"现传递的数据包序号为1000，如果接收无误，请通知我向您传递1001号数据包。"

这是首次请求连接时使用的消息，又称SYN。SYN是Synchronization的简写，表示收发数据前传输的同步消息。接下来主机B向A传递如下消息：

\[SYN+ACK\] SEQ: 2000, ACK: 1001

此时SEQ为2000，ACK为1001，而SEQ为2000的含义如下：

"现传递的数据包序号为2000，如果接收无误，请通知我向您传递2001号数据包。"而ACK 1001的含义如下：

"刚才传输的SEQ为1000的数据包接收无误，现在请传递SEQ为1001的数据包。"

对主机A首次传输的数据包的确认消息（ACK1001）和为主机B传输数据做准备的同步消息（SEO 2000）捆绑发送，因此，此种类型的消息又称SYN+ACK。

收发数据前向数据包分配序号，并向对方通报此序号，这都是为防止数据丢失所做的准备。通过向数据包分配序号并确认，可以在数据丢失时马上查看并重传丢失的数据包。因此，TCP可以保证可靠的数据传输。最后观察主机A向主机B传输的消息

\[ACK\] SEQ: 1001，ACK:2001

之前也讨论过，TCP连接过程中发送数据包时需分配序号。在之前的序号1000的基础上加1.也就是分配1001。此时该数据包传递如下消息:

已正确收到传输的SEQ为2000的数据包，现在可以传输SEQ为2001的数据包。

这样就传输了添加ACK2001的ACK消息。至此，主机A和主机B确认了彼此均就绪。

**TCP内部工作原理2：与对方主机的数据交换**

通过第一步三次握手过程完成了数据交换准备，下面就正式开始收发数据。

主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1 个数据包发送100个字节的数据，数据包的SEQ为1200。主机B为了确认这一点，向主机A发送ACK 1301消息。

此时的ACK号为1301而非1201，原因在于ACK号的增量为传输的数据字节数。假设每次ACK 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全都正确传递还是丢失了一部分，比如只传递了80字节。因此按如下公式传递ACK消息：

ACK号→SEQ号＋传递的字节数＋1

通过SEO1301数据包向主机B传递100字节数据。但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于SEO1301的ACK确认，因此试着重传该数据包。为了完成数据包重传，TCP套接字启动计时器以等待ACK应答。若相应计时器发生超时(Time-out!)则重传。


**TCP的内部工作原理3：断开与套接字的连接**

TCP套接字的结束过程也非常优雅。如果对方还有数据需要传输时直接断掉连接会出问题，所以断开连接时需要双方协商。断开连接时双方对话如下。

- 套接字A："我希望断开连接。"
- 套接字B："哦，是吗？请稍候。"
- 套接字B："我也准备就绪，可以断开连接。"
- 套接字A：“好的，谢谢合作。”

先由套接字A向套接字B传递断开连接的消息，套接字B发出确认收到的消息，然后向套接字A传递可以断开连接的消息，套接字A同样发出确认消息

数据包内的FIN表示断开连接。也就是说，双方各发送1次FIN消息后断开连接。此过程经历4个阶段，因此又称四次握手(Four-way handshaking)。SEQ和ACK的含义与之前讲解的内容一致，故省略。

前面讲解了TCP协议基本内容TCP流控制(Flow Control)希望这有助于大家理解TCP数据传输特性。




